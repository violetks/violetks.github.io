---
layout:     post
title:      面试题整理
date:       2019-11-01
author:     violetks
header-img: img/post-bg-unix-linux.jpg
catalog: true
tags:
    - 面试题
    - 基础知识
---

### 1. 常见的浏览器内核有哪些？
浏览器内核也就是渲染引擎（`Rendering Engine`），负责对网页语法的解释并渲染网页。<br>
- IE：Trident<br>
- Firefox：Gecko<br>
- Opera：Presto（已废弃），Opera现已改用Google Chrome的Blink内核。<br>
- Safari：Webkit<br>
- Chrome：Blink（基于Webkit，Google与Opera Software共同开发）

### 2. 简述事件冒泡
&nbsp;&nbsp;DOM事件流存在三个阶段：**事件捕获阶段**、**处于目标阶段**、**事件冒泡阶段**。<br>
&nbsp;&nbsp;`事件捕获`：当鼠标点击或触发DOM事件时，浏览器会从**根节点**开始**由外到内**进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应事件，会先触发父元素绑定的事件。<br>
&nbsp;&nbsp;`事件冒泡`：与事件捕获相反，事件冒泡顺序是**由内到外**进行事件传播，直到根节点。<br>
&nbsp;&nbsp;`触发顺序`：触发DOM事件时，先捕获再冒泡。<br>
两个用于事件捕获的方法：<br>
- addEventListener(event，listener，userCapture)<br>
- attachEvent（event，listener）<br>
`event`——事件名称，如click，不带on<br>
`listener`——事件监听函数<br>
`userCapture`——是否采用事件捕获，默认false是事件冒泡方式<br>

### 3. app适配是怎么写的，用什么单位？

#### 移动webapp最佳适配方案——rem
rem和html下的`font-size`有关，大部分浏览器默认字体`16px`，此时`1rem=16px`;动态修改font-size的大小就可以适配。<br>
**适配手段**<br>
1.通过media query来设置font-size<br>
```css
html {
  font-size: 20px;
}
@media only screen and (min-width: 401px){
  html {
    font-size: 25px !important;
  }
}
@media only screen and (min-width: 450px){
  html {
    font-size: 26.75px !important;
  }
}
@media only screen and (min-width: 481px){
  html {
    font-size: 30px !important;
  }
}
```
2.通过js来设置<br>
转化公式：`rem = 需要转化的px/rem基准值`<br>

rem基准值 = 设计稿的屏幕宽度/10，手动计算太累，用`sass`解决<br>

### 4. px、em、rem的区别
**px**<br>
相对长度单位，相对于显示器屏幕分辨率。px的值是固定的，浏览器不会改变其大小。<br>
**em**<br>
相对长度单位，相对于当前对象内文本的字体尺寸。如果没有设置，则相对于浏览器的默认字体尺寸。<br>
em的值不是固定的，em会继承父级元素的字体大小，**em相对于父元素**。<br>
**rem**<br>
CSS3新增的相对长度单位，**相对于HTML根元素**。需要适配各种移动设备时使用rem。<br>

### 5. get和post有什么区别？
相同点：都是异步请求的方式来获取服务端的数据。<br>
**（1）传输方式不同**：get请求会将参数加在URL后进行传递，而post请求则是作为HTTP消息的实体内容发送给Web服务器的，用户不可见。<br>
**（2）数据传输大小不同**：get方式传输的数据大小不能超过2KB，而post可以传输大量数据。<br>
**（3）安全性**：get方式请求的数据会被浏览器缓存起来，安全性低，都不安全。<br>
**（4）用户刷新时**：get方式不会有任何提示，post方式会弹出提示框，问用户是否重新提交。<br>
**（5）编码**：get只能进行URL编码，post支持多种编码方式。<br>
**（6）缓存**：get请求会被浏览器主动缓存，post不会缓存，除非手动设置。<br>

### 6. 三种存储方式：cookie、localStorage和sessionStorage
相同点：都保存在浏览器端，用于浏览器端存储的缓存数据。<br>
不同点：<br>
**①传递方式**<br>
`cookie`数据始终在**同源的http请求中携带**（即使不需要），即`cookie`在浏览器和服务器间来回传递。<br>
`sessionStorage`和`localStorage`不会自动把数据发给服务器，**仅在本地保存**。<br>
**②数据存储大小**<br>
`cookie`数据**不能超过4K**，同时因为每次http请求都会携带`cookie`，所以`cookie`只适合保存很小的数据，如**会话标识**。<br>
`sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或更大。<br>
**③数据有效期**<br>
`sessionStorage`：仅在**当前浏览器窗口关闭前**有效，不能持久保持；<br>
`localStorage`：**始终有效**，窗口或浏览器关闭也一直保存，因此用作持久数据；<br>
`cookie`：只在设置的**cookie过期时间之前**一直有效，即使窗口或浏览器关闭。<br>
**④作用域不同**<br>
`sessionStorage`**不在不同的浏览器窗口中共享**，即使是同一个页面。<br>
`cookie`和`localStorage`在同源同窗口中都是共享的。<br>

### 7. Web Storage与`cookie`相比存在的优势？
`Web Storage`包括`sessionStorage`和`localStorage`。<br>
**①存储空间更大**<br>
IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比`cookie`要大很多。<br>
**②存储内容不会发送到服务器**<br>
当设置了`cookie`后，`cookie`的内容会随着请求一并发送到服务器，这对于本地存储的数据是一种带宽浪费。而`Web Storage`中的数据则仅仅是存在本地，不会与服务器发生任何交互。<br>
**③更多丰富易用的接口**<br>
`Web Storage`提供了一套更为丰富的接口，如`setItem`,`getItem`,`removeItem`,`clear`等，使得数据操作更为简便。`cookie`需要自己封装。<br>
**④独立的存储空间**<br>
每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。<br>

### 8. 什么是跨域？跨域请求资源的方法有哪些？
**1.什么是跨域**<br>
由于浏览器的同源策略，当发送请求URL的**协议、域名、端口**三者之间任意一个与当前页面URL不同即为跨域。**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。**<br>

当前页面url | 被请求页面url | 是否跨域 | 原因
---|---|---|---
http://www.test.com/ | http://www.test.com/index.html | 否 | 同源
http://www.test.com/ | http://www.test.com/index.html | 跨域 | 协议不同（http&https）
http://www.test.com/ | http://www.baidu.com/ | 跨域 | 主域名不同
http://www.test.com/ | http://blog.test.com/ | 跨域 | 子域名不同
http://www.test.com:8080/ | http://www.test.com:80/ | 跨域 | 端口号不同
http://www.test.com/ | http://192.168.4.12/ | 跨域 | 域名和域名对应ip

**2.同源策略限制的内容**<br>
①无法读取非同源网页的Cookie、LocalStorage 和 IndexedDB<br>
②无法接触非同源网页的 DOM<br>
③无法向非同源地址发送 AJAX 请求<br>

**3.跨域解决方法**<br>
**（1）JSONP**<br>
简单适用，兼容性好，缺点是只支持get请求，不支持post请求。<br>
**原理：**ajax请求受同源策略影响，不允许进行跨域请求，而**<script>标签src属性**中的链接却可以访问跨域的js脚本，网页通过添加一个<script>元素，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。<br>
```html
// index.html
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script')
    window[callback] = function(data) {
      resolve(data)
      document.body.removeChild(script)
    }
    params = { ...params, callback } // wd=b&callback=show
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    //创建一个<script>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
  })
}

jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})
//上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&callback=show这个地址请求数据，然后后台返回show('我不爱你')，最后会运行show()这个函数，打印出'我不爱你'
```
**（2）后端在服务器上设置CORS，Nginx反向代理、node.js中间件代理跨域、后端在头部信息设置安全域名**<br>
4.相关文章：[什么是跨域？跨域解决方法](https://blog.csdn.net/qq_38128179/article/details/84956552)

### 9. 如何创建一个Ajax？
1.创建XMLHttpRequest对象

2.创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息

3.设置响应HTTP请求状态变化的函数

4.发送HTTP请求

5.获取异步调用返回的数据

6.使用JavaScript和DOM实现局部刷新