---
layout:     post
title:      Vue基础知识
date:       2019-11-05
author:     violetks
header-img: img/post-vue.jpg
catalog: true
tags:
    - Vue
    - 面试题
    - 基础知识
---

#### 1. Vue实现双向绑定的原理？
MVVM模式在于数据与视图保持同步，意思是说数据改变时会自动更新视图，视图发生变化时会更新数据。<br>
Vue采用的是**数据劫持**与**发布订阅**相结合的方式实现双向绑定。<br>
数据劫持是利用`Object.defineProperty()`方法重新定义了对象的`get`和`set`操作来实现；<br>
![](/img/post-vue-d.jpg)<br>
Object.defineProperty()三个参数：要操作的对象，要定义或修改的对象属性名，属性描述符；<br>
其中，属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符（get、set）。<br>
```javascript
var obj = {};
var name;
Object.defineProperty(obj,"data",{
  //获取值
  get.function(){
    return name;
  },
  //设置值
  set.function(val){
    name = val;
  }
});

obj.data = 'aaa';      //赋值调用set
console.log(obj.data); //取值调用get
```
**发布订阅模式实现：**<br>
- Observer监听器：用来监听属性的变化通知订阅者<br>
- Watcher订阅者：收到属性变化，然后更新视图<br>
- Compile解析器：解析指令，初始化模板，绑定订阅者<br>

参考文章：[知乎-Vue双向绑定原理](https://zhuanlan.zhihu.com/p/47541415?app=zhihulite&utm_campaign=lite_share&invite_code=8RBQBQ&sign=MTU3NTQ3MTczMjg2OA%3D%3D&ADUIN=1216612753&ADSESSION=1575638825&ADTAG=CLIENT.QQ.5603_.0&ADPUBNO=26933)

#### 2. v-if和v-show的区别
`v-if`是条件渲染指令，它根据表达式的真假来删除和插入元素；<br>
`v-show`也是条件渲染指令，元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。<br>

#### 3. v-on和v-bind的区别
`v-bind`用于设置HTML属性，如v-bind:class="exp"、v-bind:href="{{}url}"，缩写为`:class="exp"`、`:href="{{url}}"`<br>
`v-on`用于绑定HTML事件，如`v-on:click="get()"`，缩写为`@click="get()"`，**v-on可以绑定多个方法**。<br>

#### 4. v-text和v-html的区别
`v-text`渲染普通文本，会覆盖原来的内容，不解析标签。<br>
`v-html`输出真正的HTML，能解析标签，使用`v-html`的元素内部的其它元素不显示。<br>
```html
<body>
<div id="app">
  <p v-text="msg">不显示</p>
  <p v-text="html"></p>
  <p v-html="html"></p>
  <div v-html="html">
    哈哈哈哈！
	<input type="color">     //都不显示
  </div>
</div>

<script src="js/vue.js"></script>
<script>
    new Vue({
        el: '#app',
        data: {
		  msg: 'v-text显示内容',
		  html: '<strong>Hello</strong> Vue!'
        }
    });
</script>
</body>
```
v-text显示效果：<strong>Hello</strong> Vue!<br>
v-html显示效果：**Hello** Vue!<br>

#### 5. v-once有什么作用？在哪些场景下可以使用v-once？
`v-once`只渲染元素和组件一次，之后的渲染被当作静态内容跳过，用于优化更新性能。<br>
```html
<div id="app">
  <p v-once>{{msg}}</p>    //msg不会改变
  <p>{{msg}}</p>           //msg随input值动态变化
  <input type="text" v-model="msg">
</div>

<script src="js/vue.js"></script>
<script>
    new Vue({
        el: '#app',
        data: {
		  msg: 'hello!',
        }
    });
</script>
```

#### 6. v-for中key值的作用
```javascript
v-for="(item,index) in arr"
```
key的作用主要是为了**高效的更新虚拟DOM**。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。<br>
在用v-for更新已渲染的元素列表的时候，会使用**就地复用**的策略；这就是说列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改了就重新渲染，不然就复用之前的元素。<br>
属性绑定，为每一项提供一个唯一的key属性。<br>
例子：[选中一个复选框时添加一个对象](https://blog.csdn.net/Originally_M/article/details/89916856)<br>

#### 7. computed和watch有什么区别？应用场景？监听的是data里面的值吗？
1.功能上：`computed`是计算属性，依赖其他的属性计算而得出最后的值，是用于定义**基于数据之上的数据**。`watch`是监听一个值的变化并做对应的操作。<br>
2.**缓存**：`computed`结果会被缓存，只有依赖的响应式属性变化才会重新计算。而`watch`在每次监听的值发生变化时都会执行回调。<br>
3.**是否调用return**：`computed`中的函数必须要用`return`返回，`watch`中`return`不是必须的。<br>
4.如果一个值依赖多个属性（多对一），用`computed`更好，如购物车结算。如果一个值变化后会引起一系列操作或者多个值变化（一对多），用`watch`更好，如搜索框。<br>
5.在`computed`中不能对data中的属性赋值，会导致死循环。`watch`监听复杂数据类型时需用**深度监听**（在被监听对象中使用`handler`）；特殊情况下（更改数组中的数据时，数组已经更改，但是视图没有更新），watch无法监听到数组的变化。**更改数组必须要用splice()或$set。**<br>

#### 8. Vue的生命周期有哪些？它们有什么不同？
Vue生命周期是指vue实例对象从创建之初到销毁的过程。vue的生命周期总共分为8个阶段：创建前后，载入前后，更新前后，销毁前后。`beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`update`、`beforeDestroy`、`destroyed`，**第一次加载页面会触发前四个钩子**。<br>

生命周期钩子 | 组件状态 | 响应类型 | 最佳实践 
---|---|---|---
 beforeCreate | 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据 | 拿不到任何信息，无法篡改数据，一般做loading，此时的vue实例还什么都没有，但是`$route`对象是存在的，可以根据路由信息进行**重定向**之类的操作。 | 常用于初始化非响应式变量
 created | 实例创建完成，可以访问方法和数据，还未挂载到DOM，不能访问到`$el`属性，`$ref`属性内容为空数组 | `$el`，没有初始化，数据已加载完成，可以篡改数据，并更新，不会触发`beforeUpdate`，`updated`，在这结束loading，还做一些初始化，实现函数自执行 ，`$ref`属性内容为空数组；定义getter、setter存储器属性，在实例创建之后被调用，该阶段可以访问data，**可以使用this**。该阶段允许执行http请求操作。 | 常用于**简单的ajax请求**，页面的初始化
 beforeMount | 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 | $el已被初始化，数据已加载完成，阔以篡改数据，并更新，不会触发beforeUpdate，updated。将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。**相关render函数首次被调用**。 | /
 mounted | 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 | $el已被初始化，数据已加载完成，阔以篡改数据，并更新，并且触发beforeUpdate，updated，在这发起后端请求，拿回数据，配合路由钩子做一些事情；在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听 | 常用于获取信息和操作，**ajax请求**
 beforeUpdate | 响应式数据更新时调用，发生在虚拟DOM打补丁之前 | $vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改$vm.data，并不会触发附加的重渲染过程。 | 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
 updated | 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 | 虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环 | 避免在这个钩子函数中操作数据，可能陷入死循环
 beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 | / | 常用于销毁定时器、解绑全局事件、销毁插件对象等操作
 destroyed | 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 | / | /

#### 9. 数据请求在生命周期哪一个阶段？
一般在created（或beforeRouter）里面就可以，如果涉及到需要页面加载完成之后的话就用`mounted`。主要区别在于**是否需要操作DOM结构**。<br>
1.在created的时候，视图中的HTML并没有渲染出来，所以此时如果直接去操作DOM节点，一定找不到相关元素；<br>
2.在mounted中，HTML已经渲染出来了，可以直接操作DOM节点，`document.getelementById`生效。<br>

#### 10. created和mounted之间的区别？☝

### VUE中，data属性为什么要声明为一个返回初始数据的函数？

### 你有封装过axios吗？主要是封装哪方面的？

### VUE中，你知道哪几种子组件访问父组件实例的方法？

### 【VUE】你看过vue官方编码的风格指南吗？如果看过，说说你的看法。如果没有，你在开发中遵守怎样的编码规范？

### VUE中如何优化首页加载速度？

### 问：VUE中权限管理(菜单权限、接口权限)怎么处理？
#### 扩展：按钮级别的权限如何处理？

### VUE中slot是什么？你使用过吗？说说在哪些场景下使用的？

### JSX是什么？你使用过吗？说说你对它的理解

### 如何用js实现一个sleep函数？

### 【es6】你知道Proxy吗？说说你的看法？

#### 8. 在vue中，你知道哪几种定义全局的方法？
#### 扩展：你经常使用哪一种？为什么？

1:挂载到prototype
2:mixin

#### 8. Vue中组件和插件有什么区别？

组件偏向业务
插件偏向功能
并不绝对，你也可以用插件开发业务模块。
当然，实现方式也不同