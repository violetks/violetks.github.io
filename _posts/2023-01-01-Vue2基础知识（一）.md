---
layout:     post
title:      Vue2基础知识（一）
date:       2023-01-01
author:     violetks
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - Vue2
---

#### 一、Vue是什么
Vue是一套用于构建用户界面的渐进式JavaScript框架。**渐进式**可以理解为Vue可以自底向上逐层应用，从一个轻量小巧的核心库逐渐递进到可以引入各种Vue插件。<br>

#### 二、Vue的特点
1、采用组件化模式，提高代码复用率，且让代码更好维护；<br>
2、声明式渲染，Vue的核心是一个允许采用**模板语法**来声明式地将数据渲染进DOM的系统。让编码人员无需直接操作DOM，提高开发效率；<br>
3、使用虚拟DOM和Diff算法，尽量复用DOM节点。<br>

#### 三、Vue实例和容器只能一一对应

#### 四、Vue模板语法
1、插值表达式：用于解析标签体内容，`{% raw %}{{data}}{% endraw %}`；<br>
2、指令语法：用于解析标签，例如`v-bind:href="xxx"`。<br>

#### 五、Vue内置指令
1、`v-bind`：单向数据绑定，数据变化能改变视图，但视图变化不能改变数据；<br>
2、`v-model`：双向数据绑定，只能应用在表单类元素上。`v-model:value`可简写为`v-model`，因为`v-model`默认收集的是value值；`v-model`的修饰符：`.number`、`.lazy`、`.trim`；<br>
3、`v-on`：用于监听DOM事件，并在触发时运行一些JavaScript代码；<br>
4、条件渲染指令：`v-show`、`v-if`、`v-else-if`、`v-else`，`<template>`标签不影响HTML结构，但只能和`v-if`使用，`v-show`不支持`<template>`；<br>
5、列表渲染指令：`v-for`，可遍历数组、对象、字符串、数字，`v-for`具有比`v-if`更高的优先级，不推荐一起使用；<br>
6、`v-text`：渲染普通文本；<br>
7、`v-html`：更新元素的`innerHTML`，有安全性问题，容易导致XSS攻击；<br>
8、`v-once`：元素或组件只渲染一次；<br>
9、`v-slot`：提供具名插槽或需要接收prop的插槽；<br>
10、`v-cloak`：这个指令保持在元素上直到关联实例结束编译；<br>
11、`v-pre`：跳过这个元素和它的子元素的编译过程，加快编译；<br>
12、自定义指令：<br>
（1）定义语法：<br>
```javascript
// 局部指令
new Vue({
  directives: { 指令名: 配置对象 }
  directives () {} // 函数式
})
// 全局指令
Vue.directive(指令名, 配置对象)
Vue.directive(指令名, 回调函数)
```
（2）配置对象中常用的三个回调：<br>
①`bind`：只调用一次，指令第一次绑定到元素时调用；<br>
②`inserted`：指令所在元素被插入页面时调用；<br>
③`update`：指令所在模板结构被重新解析时调用。<br>
（3）注意事项：自定义指令里的this指向window；指令名如果是多个单词，用`kebab-case`形式。<br>
```html
<!-- 具名插槽 -->
<base-layout>
  <template v-slot:header>
    Header content
  </template>

  Default slot content

  <template v-slot:footer>
    Footer content
  </template>
</base-layout>

<!-- 接收 prop 的具名插槽 -->
<infinite-scroll>
  <template v-slot:item="slotProps">
    <div class="item">
      {% raw %}{{ slotProps.item.text }}{% endraw %}
    </div>
  </template>
</infinite-scroll>

<!-- 接收 prop 的默认插槽，使用了解构 -->
<mouse-position v-slot="{ x, y }">
  Mouse position: {% raw %}{{ x }}{% endraw %}, {% raw %}{{ y }}{% endraw %}
</mouse-position>
```

#### 六、v-if和v-show的区别
`v-if`是条件渲染指令，它根据表达式的真假来删除和插入元素；<br>
`v-show`也是条件渲染指令，元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。<br>

#### 七、v-on和v-bind的区别
`v-bind`用于设置HTML属性，如{% raw %}v-bind:class="exp"{% endraw %}、{% raw %}v-bind:href="{{url}}"{% endraw %}，缩写为:class="exp"、{% raw %}:href="{{url}}"{% endraw %}；<br>
`v-on`用于绑定HTML事件，如`v-on:click="get()"`，缩写为`@click="get()"`，**v-on可以绑定多个方法**。<br>

#### 八、v-text和v-html的区别
`v-text`渲染普通文本，会覆盖原来的内容，不解析标签。<br>
`v-html`输出真正的HTML，能解析标签，使用`v-html`的元素内部的其它元素不显示。<br>
```html
<body>
<div id="app">
  <p v-text="msg">不显示</p>
  <p v-text="html"></p>
  <p v-html="html"></p>
  <div v-html="html">
    哈哈哈哈！
    <input type="color">     //都不显示
  </div>
</div>

<script src="js/vue.js"></script>
<script>
  new Vue({
      el: '#app',
      data: {
        msg: 'v-text显示内容',
        html: '<strong>Hello</strong> Vue!'
      }
  });
</script>
</body>
```
v-text显示效果：<xmp><strong>Hello</strong> Vue!</xmp><br>
v-html显示效果：**Hello** Vue!<br>

#### 九、v-once有什么作用？在哪些场景下可以使用v-once？
`v-once`只渲染元素和组件一次，之后的渲染被当作静态内容跳过，用于优化更新性能。<br>
```html
<div id="app">
  <p v-once>{% raw %}{{msg}}{% endraw %}</p>    //msg不会改变
  <p>{% raw %}{{msg}}{% endraw %}</p>           //msg随input值动态变化
  <input type="text" v-model="msg">
</div>

<script src="js/vue.js"></script>
<script>
  new Vue({
      el: '#app',
      data: {
        msg: 'hello!'
      }
  });
</script>
```

#### 十、v-for中key值的作用
```javascript
v-for="(item,index) in arr"
```
例子：[选中一个复选框时添加一个对象](https://blog.csdn.net/Originally_M/article/details/89916856)<br>
1、key的作用主要是为了**高效的更新虚拟DOM**。key作为虚拟DOM对象的标识，当数据发生变化时，Vue会根据“新数据”生成“新的虚拟DOM”，随后Vue进行“新虚拟DOM”与“旧虚拟DOM”的差异对比。比较规则如下：<br>
（1）旧虚拟DOM中找到了与新虚拟DOM相同的key，对比发现新旧虚拟DOM中内容没变时直接使用之前的真实DOM，也就是就地复用；对比发现内容变了，则生成新的真实DOM，随后替换页面中之前的真实DOM；<br>
（2）旧虚拟DOM中未找到与新虚拟DOM相同的key，则会创建新的真实DOM，随后渲染到页面。<br>
2、用`index`作为key值可能会引发的问题：若对数据进行增删改查等破坏顺序的操作，可能导致所有元素的key值发生改变，diff算法无法关联到旧虚拟DOM中一样的数据，会产生没有必要的真实DOM更新。<br>

#### 十一、Vue实现双向绑定的原理
目前前端框架基本上都是采用**MVVM模式**（Model-View-ViewModel）实现双向绑定，MVVM模式在于数据与视图保持同步，意思是说数据改变时会自动更新视图，视图发生变化时会更新数据。`ViewModel`是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的。<br>
Vue采用的是**数据劫持**与**发布订阅**相结合的方式实现双向绑定。<br>
数据劫持是利用`Object.defineProperty()`方法重新定义了对象的`get`和`set`操作来实现。<br>
![aGPR6U.jpg](https://s1.ax1x.com/2020/08/01/aGPR6U.jpg)<br>
<!-- ![aGPR6U.jpg](/instructPic/aGPR6U.jpg) -->
Object.defineProperty()三个参数：要操作的对象，要定义或修改的对象属性名，属性描述符。<br>
其中，属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符（get、set）。<br>
```javascript
var obj = {};
var name;
Object.defineProperty(obj, "data", {
  // 获取值
  get: function () {
    return name;
  },
  // 设置值
  set: function (val) {
    name = val;
  }
});

obj.data = 'aaa';      //赋值调用set
console.log(obj.data); //取值调用get
```

Object.defineProperty()里的其他属性：<br>
```javascript
let person = { name: "张三", sex: "男" };
Object.defineProperty(person, "age", {
  value: 18, // 设置 age 属性的数据值为 18，默认值为 undefined
  enumerable: true, // 控制属性是否可以枚举，默认值为 false
  writable: true, // 控制属性是否可以被修改，默认值为 false
  configurable: true // 控制属性是否可以被删除，默认值为 false
});
```
**发布订阅模式实现：**<br>
- Observer监听器：用来监听属性的变化通知订阅者<br>
- Watcher订阅者：收到属性变化，然后更新视图<br>
- Compile解析器：解析指令，初始化模板，绑定订阅者<br>

参考文章：[知乎-Vue双向绑定原理](https://zhuanlan.zhihu.com/p/47541415?app=zhihulite&utm_campaign=lite_share&invite_code=8RBQBQ&sign=MTU3NTQ3MTczMjg2OA%3D%3D&ADUIN=1216612753&ADSESSION=1575638825&ADTAG=CLIENT.QQ.5603_.0&ADPUBNO=26933)

#### 十二、Vue中的数据代理
1、数据代理：通过一个对象代理对另一个对象中的数据的操作（读/写）。<br>
2、Vue中的数据代理就是通过`Object.defineProperty()`把`data对象`中所有的属性添加到`vm`上，且数据从`data`到`vm`中的过程，又为每一个属性添加上`getter`和`setter`方法，用户修改或者读取时，也是通过`getter`或`setter`方法访问`_data`，`_data`返回或操作`data`中的数据实现的。<br>

#### 十三、事件处理
```html
<button @click="showInfo">不传参，默认参数有原生事件对象event</button>

<button @click="showInfo(66, $event)">传参，并传入原生事件对象event</button>
```

#### 十四、事件修饰符
1、`.stop`：阻止事件冒泡；<br>
2、`.prevent`：阻止默认事件，比如阻止a标签默认的跳转事件；<br>
3、`.capture`：使用事件的捕获模式；<br>
4、`.self`：只有event.target是当前操作的元素时才触发事件；<br>
5、`.once`：事件只触发一次；<br>
6、`.passive`：事件的默认行为立即执行，无需等待事件回调执行完毕；<br>
7、`.native`：监听组件根元素的原生事件；<br>
```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联，要注意先后顺序 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>

<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<!-- scroll是滚动条事件，wheel是滚轮事件 -->
<div v-on:scroll.passive="onScroll">...</div>
```

#### 十五、按键修饰符
```html
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```
1、Vue中常用的按键码的别名：`.enter`、`.tab`(配合keyup不生效，要配合keydown)、`.delete`（捕获“删除”和“退格”键）、`.esc`、`.space`、`.up`、`.down`、`.left`、`.right`；<br>
2、Vue未提供别名的按键，可以使用按键原始的key值去绑定，注意像CapsLock键要写为`kebab-case`形式：@keyup.caps-lock；<br>
3、系统修饰键：`.ctrl`、`.alt`、`.shift`、`.meta`。<br>
（1）配合`keyup`使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发；<br>
（2）配合`keydown`使用：正常触发事件。<br>
```html
<!-- Alt + C -->
<input v-on:keyup.alt.67="clear">

<!-- Ctrl + Click -->
<div v-on:click.ctrl="doSomething">Do something</div>
```
4、自定义按键修饰符别名：Vue.config.keyCodes.自定义键名 = 键码。<br>

#### 十六、computed和watch有什么区别？应用场景？监听的是data里面的值吗？
1、**功能上**：`computed`是计算属性，依赖其他的属性计算而得出最后的值，是用于定义**基于数据之上的数据**。`watch`是监听一个值的变化并做对应的操作。<br>
2、**缓存**：`computed`结果会被缓存，只有依赖的响应式属性变化才会重新计算。而`watch`在每次监听的值发生变化时都会执行回调。<br>
3、**是否调用return**：`computed`中的函数必须要用`return`返回，`watch`中`return`不是必须的。<br>
4、**应用场景**：如果一个值依赖多个属性（多对一），用`computed`更好，如购物车结算，比如查询表单配置数组。如果一个值变化后会引起一系列操作或者多个值变化（一对多），用`watch`更好，如搜索框。<br>
5、在`computed`中不能对data中的属性赋值，会导致死循环。`watch`监听复杂数据类型时需用**深度监听**（在被监听对象中使用`handler`）；特殊情况下（更改数组中的数据时，数组已经更改，但是视图没有更新），watch无法监听到数组的变化。**更改数组必须要用splice()或$set。**<br>
6、watch可以监听data中的数据，还可以监听props、$route、$emit、computed里的数据。<br>
7、监听API用法：vm.$watch；<br>
8、watch的两个属性：`immediate`（初始化时调用）和`deep`（深度监听对象属性值的变化）。<br>
9、在一个组件中使用多个`watch`监听多个值时，它们的执行顺序是随机不受控制的，尽量少用`watch`。<br>

#### 十七、Vue监测数据的原理
1、Vue会监视data中所有层次的数据；<br>
2、如何监测对象中的数据？<br>
通过`setter`实现监视，且要在new Vue创建实例对象时就传入要监测的数据。<br>
（1）对象中后追加的属性，Vue默认不做响应式处理；<br>
（2）如需给后添加的属性做响应式，请使用如下API：`Vue.set(target,propertyName/index,value)`或`vm.$set()`。<br>
3、如何监测数组中的数据？<br>
通过包裹数组更新元素的方式实现，本质就是做了两件事：<br>
（1）调用原生对应的方法对数组进行更新；<br>
（2）重新解析模板，进而更新页面。<br>
4、在Vue修改数组中的某个元素一定要用如下方法：<br>
（1）使用这些API：`push()`、`pop()`、`shift()`、`unshift()`、`splice()`、`sort()`、`reverse()`；<br>
（2）使用`Vue.set()`或`vm.$set()`，注意`Vue.set()`或`vm.$set()`不能给vm或vm的根数据对象添加属性。<br>

#### 十八、$set的作用
由于Javascript的限制，Vue中并不是任何时候数据都是双向绑定的，这时可以使用`$set`解决双向绑定失效的问题。<br>
**出现双向绑定失效的情况：**<br>
（1）利用索引直接设置一个数组项，例如：vm.items[index] = newValue；<br>
（2）修改数组的长度，例如：vm.items.length = newLength；<br>
（3）对象属性的添加或删除操作。<br>
```javascript
var vm = new Vue({
  data: {
    a: 1
  }
})

// `vm.a` 是响应式的

vm.b = 2
// `vm.b` 是非响应式的

// 添加响应式属性
Object.assign(this.someObject, { a: 1, b: 2 }) // 不会响应
// 需要用原对象与要混合进去的对象一起创建一个新的对象
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

#### 十九、过滤器
1、创建一个过滤器；<br>
（1）全局过滤器：<br>
```javascript
Vue.filter('capitalize', function (value) {
  if (!value) return '';
  value = value.toString();
  return value.charAt(0).toUpperCase() + value.slice(1);
})

new Vue({
  // ...
})
```
（2）局部过滤器：在一个组件的选项中定义本地的过滤器：<br>
```javascript
new Vue({
  filters: {
    capitalize: function (value) {
      if (!value) return '';
      value = value.toString();
      return value.charAt(0).toUpperCase() + value.slice(1);
    }
  }
})
```
**注意**：当全局过滤器和局部过滤器重名时，会采用局部过滤器。<br>
2、使用过滤器：插值表达式或`v-bind`；<br>
```html
<!-- 在双花括号中 -->
{% raw %}{{ message | capitalize }}{% endraw %}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```
3、过滤器也可以接收额外参数，多个过滤器可以串联；<br>
```html
{% raw %}{{ message | filterA | filterB }}{% endraw %}

{% raw %}{{ message | filterA('arg1', arg2) }}{% endraw %}
```
4、过滤器并没有改变原本的数据，是产生新的对应的数据。<br>
