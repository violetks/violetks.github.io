---
layout:     post
title:      æ•°æ®ç»“æ„é¢˜
subtitle:   ä»¥å‰çš„å‡ é“æ•°æ®ç»“æ„ä½œä¸šï¼Œè™½ç„¶ç°åœ¨çœ‹ä¸æ‡‚äº†ğŸ˜‚
date:       2019-12-01
author:     violetks
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - æ•°æ®ç»“æ„
    - ç®—æ³•é¢˜
    - Cè¯­è¨€
---

## å®éªŒä¸€ æ•°åˆ¶è½¬æ¢

å®éªŒåç§°ï¼šå®ç°åè¿›åˆ¶æ•´æ•° N å‘å…¶å®ƒè¿›åˆ¶æ•° dï¼ˆäºŒã€å…«ã€åå…­ï¼‰çš„è½¬æ¢

ã€æ•°æ®ç»“æ„ã€‘:

```
#define S_SIZE 100 //æ ˆçš„ç©ºé—´å¤§å° 
#define STACKINCREAMENT 10 //å¢åŠ ç©ºé—´ 
struct SqStack{ 
  int *base; //æ ˆåº• 
  int *top; //æ ˆé¡¶ 
  int stacksize; //æ ˆå½“å‰çš„å­˜å‚¨ç©ºé—´ 
};
```

ã€ç®—æ³•æ€æƒ³ã€‘:

```
void InitStack(SqStack &S); //åˆå§‹åŒ–ç©ºæ ˆ 
int StackEmpty(SqStack S); //åˆ¤ç©º 
void GetTop(SqStack S, int &e);//è·å¾—æ ˆé¡¶å…ƒç´  
void push(SqStack &S, int e);//è¿›æ ˆ 
void pop(SqStack &S, int &e);//å‡ºæ ˆ 
void convert(SqStack &S, int N, int n);//åè¿›åˆ¶è½¬ N è¿›åˆ¶ 

unsigned n, N;//è¦è½¬æ¢æˆçš„è¿›åˆ¶æ•°å’Œè¦è½¬æ¢çš„æ•° 
SqStack s; 
InitStack(s);//åˆå§‹åŒ–ç©ºæ ˆ 
printf("è¾“å…¥è¦è½¬æ¢çš„åè¿›åˆ¶æ•°å’Œè¦è½¬æ¢ä¸ºçš„è¿›åˆ¶æ•°:\n"); 
scanf("%d,%d", &N, &n); 
printf("%d è½¬æ¢ä¸º%d è¿›åˆ¶åä¸º:\n", N, n); 
convert(s, N, n);
```

ã€ç®—æ³•æè¿°ã€‘:

```
void InitStack(SqStack &S) 
{ 
  S.base = (int *)malloc(S_SIZE*sizeof(int)); 
  S.stacksize = S_SIZE; 
  S.top = S.base;//åˆå§‹åŒ–ç©ºæ ˆ 
}
int StackEmpty(SqStack S) 
{ 
  if (S.base == S.top) 
    return 1; 
  else 
    return 0; 
}
void GetTop(SqStack S, int &e) 
{//è·å¾—æ ˆé¡¶å…ƒç´  
  e = *(S.top - 1);
}
void push(SqStack &S, int e) 
{//è¿›æ ˆ
  if (S.top - S.base >= S.stacksize) 
  { 
    S.base=(int *)realloc(S.base,(S.stacksize+STACKINCREAMENT)*sizeof(int)); 
    S.top=S.base+S.stacksize; 
    S.stacksize+=STACKINCREAMENT; 
  }
  *(S.top)=e; 
  S.top++; 
}
void pop(SqStack &S,int &e) 
{//å‡ºæ ˆ
  if(S.base !=S.top) 
  { 
    S.top--; 
    e=*S.top; 
  } 
}
void convert(SqStack &S, int N,int n) 
{ 
  InitStack(S); 
  do{ 
    push(S,N%n); 
    N /= n; 
  }while(N!=0); 
  int e; 
  while(!StackEmpty(S)) 
  { 
    pop(S,e); 
    if(e>9)//åå…­è¿›åˆ¶æ—¶è¾“å‡ºå­—æ¯ 
    { 
      e=e+55; 
      printf(â€œ%câ€,e); 
    }else
      printf(â€œ%dâ€,e); 
  }
  printf(â€œ\nâ€); 
}
```

![convert](/img/post-convert.png)

## å®éªŒäºŒ	å•é“¾è¡¨çš„æ’å…¥åˆ é™¤

```
#include<stdio.h> 
#include<stdlib.h> 
#include<malloc.h> 
#define M 100
typedef int Etype; //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹å€¼çš„ç±»å‹ä¸ºæ•´å‹

typedef struct Node
{
  Etype data;	        //å•é“¾è¡¨ä¸­çš„æ•°æ®åŸŸ
  struct Node *link;		//å•é“¾è¡¨çš„æŒ‡é’ˆåŸŸ
}Node;
typedef Node *List;	//å®šä¹‰å•é“¾è¡¨

List BuildList1(); 
List BuildList2();
void PrintList(List first); 
void clear(List *first);

//å¤´æ’æ³•å»ºç«‹é“¾è¡¨
List BuildList1()
{
  Node *L; 
  Etype x,n;
  L = (Node *)malloc(sizeof(Node));	//ç”³è¯·å¤´ç»“ç‚¹ç©ºé—´
  L->link = NULL;	//åˆå§‹åŒ–ä¸€ä¸ªç©ºé“¾è¡¨printf("è¯·è¾“å…¥å…ƒç´ ä¸ªæ•°ï¼š\n");
  scanf("%d",&n);
  printf("è¯·è¾“å…¥å…ƒç´ ï¼š\n");	//x ä¸ºé“¾è¡¨æ•°æ®åŸŸä¸­çš„æ•°æ®
  for(int i=0;i<n;i++)
  {
    scanf("%d",&x); 
    Node *p;
    p = (Node *)malloc(sizeof(Node));		//ç”³è¯·æ–°çš„ç»“ç‚¹
    p->data = x;	//ç»“ç‚¹æ•°æ®åŸŸèµ‹å€¼
    p->link = L->link;	//å°†ç»“ç‚¹æ’å…¥åˆ°è¡¨å¤´ L-->|2|-->|1|-->NULL 
    L->link = p;
  }
  return L;
}

//å°¾æ’æ³•å»ºç«‹é“¾è¡¨
List BuildList2()
{
  Node *L,*r; 
  Etype n,x;
  L = (Node *)malloc(sizeof(Node));		//ç”³è¯·å¤´ç»“ç‚¹ç©ºé—´
  L->link = NULL;	//åˆå§‹åŒ–ä¸€ä¸ªç©ºé“¾è¡¨
  printf("è¯·è¾“å…¥å…ƒç´ ä¸ªæ•°ï¼š\n");
  scanf("%d",&n);
  r = L;	//r å§‹ç»ˆæŒ‡å‘ç»ˆç«¯ç»“ç‚¹ï¼Œå¼€å§‹æ—¶æŒ‡å‘å¤´ç»“ç‚¹
  printf("è¯·è¾“å…¥å…ƒç´ ï¼š\n");
  for(int i=0;i<n;i++)
  {
    scanf("%d",&x); 
    Node *p;
    p = (Node *)malloc(sizeof(Node));	//ç”³è¯·æ–°çš„ç»“ç‚¹
    p->data = x;	//ç»“ç‚¹æ•°æ®åŸŸèµ‹å€¼
    r->link = p;	//å°†ç»“ç‚¹æ’å…¥åˆ°è¡¨å¤´ L-->|1|-->|2|-->NULL 
    r = p;
  }
  r->link = NULL;

  return L;
}

//è¾“å‡ºé“¾è¡¨
void PrintList(List first)
{
  Node *Li; 
  if(first==NULL)
  {
    printf("é“¾è¡¨ä¸ºç©ºï¼\n"); 
    return;
  }
  Li=first->link; 
  while(Li!=NULL)
  {
    printf("%d ",Li->data); 
    Li=Li->link;
  }
  printf("\n");
}

//æ¸…ç©ºé“¾è¡¨ 
void clear(List *first) 
{ 
  Node *p=*first; 
  while(*first) 
  { 
    p=(*first)->link; 
    free(*first); 
    *first=p; 
  } 
}
int main() 
{ 
  Node *L; 
  L=BuildList1(); //è°ƒç”¨ BuiltdList1(å‰æ’æ³•)å»ºç«‹å•é“¾è¡¨ç®—æ³• 
  PrintList(L); //æ‰“å°å•é“¾è¡¨ 
  clear(&L);//æ¸…ç©ºå•é“¾è¡¨ 
  L=BuildList2(); //è°ƒç”¨ BuiltdList2(åæ’æ³•)å»ºç«‹å•é“¾è¡¨ç®—æ³• 
  PrintList(L); //æ‰“å°å•é“¾è¡¨ 
  clear(&L);//æ¸…ç©ºå•é“¾è¡¨ 
}
```

## å®éªŒä¸‰ äºŒå‰æ ‘çš„éå†

```
#include<iostream.h> 

struct BiNode 
{
  char data; 
  BiNode *lchild,*rchild; 
};

class BiTree 
{
  public: 
  BiTree(){root=Creat(root);} 
  ~BiTree(){Release(root);} 
  void PreOrder(){PreOrder(root);} 
  void InOrder(){InOrder(root);} 
  void PostOrder(){PostOrder(root);} 
  
  private: 
  BiNode *root; 
  BiNode *Creat(BiNode *bt); 
  void Release(BiNode *bt);
  void PreOrder(BiNode *bt); 
  void InOrder(BiNode *bt); 
  void PostOrder(BiNode *bt); 
};

BiNode *BiTree::Creat(BiNode *bt) 
{
  char ch; 
  cin>>ch; 
  if(ch=='#')
    return NULL; 
  else 
  {
    bt=new BiNode; 
    bt->data=ch; 
    bt->lchild=Creat(bt->lchild); 
    bt->rchild=Creat(bt->rchild); 
  } 
  return bt; 
}

void BiTree::Release(BiNode *bt) 
{
  if(bt!=NULL) 
  {
    Release(bt->lchild); 
    Release(bt->rchild); 
    delete bt; 
  } 
}

void BiTree::PreOrder(BiNode *bt) 
{
  if(bt==NULL) 
    return; 
  else 
  {
    cout<<bt->data<<" "; 
    PreOrder(bt->lchild); 
    PreOrder(bt->rchild); 
  }
}

void BiTree::InOrder(BiNode *bt) 
{
  if(bt==NULL) return;
  else
  {
    InOrder(bt->lchild); 
    cout<<bt->data<<" "; 
    InOrder(bt->rchild);
  }
}

void BiTree::PostOrder(BiNode *bt)
{
  if(bt==NULL) return; 
  else
  {
    PostOrder(bt->lchild); 
    PostOrder(bt->rchild);
    cout<<bt->data<<" ";
  }
}

int main()
{
  cout<<"è¯·è¾“å…¥åˆ›å»ºä¸€æ£µäºŒå‰æ ‘çš„ç»“ç‚¹æ•°æ®"<<endl; 
  BiTree T;
  cout<<"-----å‰åºéå†	"<<endl;
  T.PreOrder(); 
  cout<<endl;
  cout<<"-----ä¸­åºéå†	"<<endl;
  T.InOrder();
  cout<<endl;
  cout<<"-----ååºéå†	"<<endl;
  T.PostOrder(); 
  cout<<endl; 
  return 0;
}
```

![bitree](/img/post-bitree.png)

## å®éªŒå›› èµ«å¤«æ›¼æ ‘

```
void HuffmanCoding(HuffmanTree &HT, HuffmanCode &HC, int *w, int n) { 
  // ç®—æ³• 6.12 
  // w å­˜æ”¾ n ä¸ªå­—ç¬¦çš„æƒå€¼(å‡>0)ï¼Œæ„é€ å“ˆå¤«æ›¼æ ‘ HTï¼Œ 
  // å¹¶æ±‚å‡º n ä¸ªå­—ç¬¦çš„å“ˆå¤«æ›¼ç¼–ç  HC 
  int i, j, m, s1, s2, start; 
  char *cd; 
  unsigned int c, f; 
  
  if (n<=1) return; 
  m = 2 * n - 1; 
  HT = (HuffmanTree)malloc((m+1) * sizeof(HTNode)); // 0 å·å•å…ƒæœªç”¨ 
  for (i=1; i<=n; i++) { //åˆå§‹åŒ– 
    HT[i].weight=w[i-1]; 
    HT[i].parent=0; 
    HT[i].lchild=0; 
    HT[i].rchild=0; 
  }
  for (i=n+1; i<=m; i++) { //åˆå§‹åŒ– 
    HT[i].weight=0; 
    HT[i].parent=0; 
    HT[i].lchild=0; 
    HT[i].rchild=0; 
  }
  printf("\n å“ˆå¤«æ›¼æ ‘çš„æ„é€ è¿‡ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š\n"); 
  printf("HT åˆæ€:\n ç»“ç‚¹ weight parent lchild rchild"); 
  for (i=1; i<=m; i++) 
    printf("\n%4d%8d%8d%8d%8d",i,HT[i].weight, HT[i].parent,HT[i].lchild, HT[i].rchild); 
    printf(" æŒ‰ä»»æ„é”®ï¼Œç»§ç»­ ..."); 
    getch(); 
  for (i=n+1; i<=m; i++) { // å»ºå“ˆå¤«æ›¼æ ‘ 
    // åœ¨ HT[1..i-1]ä¸­é€‰æ‹© parent ä¸º 0 ä¸” weight æœ€å°çš„ä¸¤ä¸ªç»“ç‚¹ï¼Œ 
    // å…¶åºå·åˆ†åˆ«ä¸º s1 å’Œ s2ã€‚ 
    Select(HT, i-1, s1, s2); 
    HT[s1].parent = i; HT[s2].parent = i; 
    HT[i].lchild = s1; HT[i].rchild = s2; 
    HT[i].weight = HT[s1].weight + HT[s2].weight; 
    printf("\nselect: s1=%d s2=%d\n", s1, s2); 
    printf(" ç»“ç‚¹ weight parent lchild rchild"); 
    for (j=1; j<=i; j++) 
      printf("\n%4d%8d%8d%8d%8d",j,HT[j].weight, HT[j].parent,HT[j].lchild, HT[j].rchild);
      printf(" æŒ‰ä»»æ„é”®ï¼Œç»§ç»­ ..."); 
      getch(); 
  }
  
  //--- ä»å¶å­åˆ°æ ¹é€†å‘æ±‚æ¯ä¸ªå­—ç¬¦çš„å“ˆå¤«æ›¼ç¼–ç  --- 
  cd = (char *)malloc(n*sizeof(char)); // åˆ†é…æ±‚ç¼–ç çš„å·¥ä½œç©ºé—´ 
  cd[n-1] = '\0'; // ç¼–ç ç»“æŸç¬¦ã€‚ 
  for (i=1; i<=n; ++i) { // é€ä¸ªå­—ç¬¦æ±‚å“ˆå¤«æ›¼ç¼–ç  
    start = n-1; // ç¼–ç ç»“æŸç¬¦ä½ç½® 
    for (c=i, f=HT[i].parent; f!=0; c=f, f=HT[f].parent) 
      // ä»å¶å­åˆ°æ ¹é€†å‘æ±‚ç¼–ç  
      if (HT[f].lchild==c) 
        cd[--start] = '0'; 
      else 
        cd[--start] = '1'; 
    HC[i] = (char *)malloc((n-start)*sizeof(char)); // ä¸ºç¬¬ i ä¸ªå­—ç¬¦ç¼–ç åˆ†é…ç©ºé—´ 
    strcpy(HC[i], &cd[start]); // ä» cd å¤åˆ¶ç¼–ç (ä¸²)åˆ° HC 
  }
  free(cd); // é‡Šæ”¾å·¥ä½œç©ºé—´ 
} // HuffmanCoding

![huffman](/img/post-huffman.png)

```
