---
layout:     post
title:      Vue2基础知识（二）
date:       2023-01-02
author:     violetks
header-img: img/post-vue.jpg
catalog: true
tags:
    - Vue
---

#### 一、Vue的生命周期有哪些？它们有什么不同？
Vue生命周期是指vue实例对象从创建之初到销毁的过程。vue的生命周期总共分为8个阶段：创建前后，载入前后，更新前后，销毁前后。`beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`update`、`beforeDestroy`、`destroyed`，**第一次加载页面会触发前四个钩子**。<br>

生命周期钩子 | 组件状态 | 响应类型 | 最佳实践
---|---|---|---
 beforeCreate | 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据 | 拿不到任何信息，无法篡改数据，一般做loading，此时的vue实例还什么都没有，但是`$route`对象是存在的，可以根据路由信息进行**重定向**之类的操作。 | 常用于初始化非响应式变量
 created | 实例创建完成，可以访问方法和数据，还未挂载到DOM，不能访问到`$el`属性，`$ref`属性内容为空数组 | `$el`，没有初始化，数据已加载完成，可以篡改数据，并更新，不会触发`beforeUpdate`，`updated`，在这结束loading，还做一些初始化，实现函数自执行 ，`$ref`属性内容为空数组；定义getter、setter存储器属性，在实例创建之后被调用，该阶段可以访问data，**可以使用this**。该阶段允许执行http请求操作。 | 常用于**简单的ajax请求**，页面的初始化
 beforeMount | 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 | $el已被初始化，数据已加载完成，可以篡改数据，并更新，不会触发beforeUpdate，updated。将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。**相关render函数首次被调用**。 | /
 mounted | 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 | $el已被初始化，数据已加载完成，可以篡改数据，并更新，并且触发beforeUpdate，updated，在这发起后端请求，拿回数据，配合路由钩子做一些事情；在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听 | 常用于获取信息和操作，**ajax请求**
 beforeUpdate | 响应式数据更新时调用，发生在虚拟DOM打补丁之前 | $vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改$vm.data，并不会触发附加的重渲染过程。 | 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
 updated | 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 | 虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环 | 避免在这个钩子函数中操作数据，可能陷入死循环
 beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 | / | 常用于销毁定时器、解绑全局事件、销毁插件对象等操作
 destroyed | 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 | / | /

 ![lbhGrR.jpg](https://s2.ax1x.com/2020/01/14/lbhGrR.jpg)
 <!-- ![lbhGrR.jpg](/instructPic/lbhGrR.jpg) -->

#### 二、数据请求在生命周期哪一个阶段？created和mounted之间的区别？
一般在`created`（或beforeRouter）里面就可以，如果涉及到需要页面加载完成之后的话就用`mounted`。主要区别在于**是否需要操作DOM结构**。<br>
1、在`created`的时候，视图中的HTML并没有渲染出来，所以此时如果直接去操作DOM节点，一定找不到相关元素；<br>
2、在`mounted`中，HTML已经渲染出来了，可以直接操作DOM节点，`document.getelementById`生效。<br>

#### 三、Vue组件基础
Vue组件是可复用的Vue实例，它们与`new Vue`接收相同的选项，例如`data`、`computed`、`watch`、`methods`以及生命周期钩子等。注意每个组件都会各自独立维护它的数据，每用一次组件，就会有一个它的新实例被创建。<br>
Vue中使用组件的三大步骤：1、创建组件，使用`Vue.extend(options)`；2、注册组件；3、使用组件；<br>
```javascript
// 注册一个全局组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
// 注册一个局部组件
components: {...}
```

#### 四、Vue中，data属性为什么必须声明为一个返回初始数据的函数？
data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，互不影响。如果不用function返回，每个组件的data都是内存的同一个地址，一个实例中数据改变了其他实例的也跟着改变。data函数中的this是Vue实例对象。<br>
```javascript
//如果直接赋值，两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改
var MyComponent = function() {}
MyComponent.prototype.data = {
  a: 1,
  b: 2
}

//两个组件实例，通过<my-component>调用，创建的两个实例
var component1 = new MyComponent()
var component2 = new MyComponent()

component1.data.a === component2.data.a;  //true
component1.data.b = 5;
component2.data.b;  //5
```
```html
Vue.component('my-component',{
  template: '<div>OK</div>',
  data() {
    return {} //返回一个唯一的对象，不要和其他组件共用一个对象进行返回
  }
})
```

#### 1五、Vue的slot插槽（匿名&具名&作用域）
Vue实现了一套内容分发的API，将`<slot></slot>`元素作为承载分发内容的出口，没有插槽的情况下在组件标签内一些内容是不起任何作用的。<br>
**具名插槽**，当需要使用插槽时，可以使用`<slot>`的特性`:name`，定义额外的插槽。<br>
**作用域插槽**，作用域插槽就是父组件在**调用子组件的时候给子组件传了一个插槽**，这个插槽为作用域插槽，该插槽必须放在`<template>`标签里面，同时声明从子组件接收的数据放在一个自定义属性内，并定义该数据的渲染方式。<br>
在2.6.0中，为具名插槽和作用域插槽引入了一个`v-slot`指令，它取代了`slot`和`slot-scope`。<br>
```html
<div id="app">
<child>
  <template slot-scope="props">  <!--该插槽必须放在template标签内-->
    <li></li>  <!--定义渲染方式-->
  </template>
</child>
</div>
```
```html
Vue.component('child',{
  data: {
    list:[1,2,3,4]
  },
  template:`<div>
                <ul>
                   <slot v-for="value in list" :value=value>  //使用slot占位
                   </slot>
                </ul>
            </div>`
})
new Vue({
  el: '#app'
})
```

#### 六、$route和$router的区别
`$router`是一个VueRouter的实例，可以导航到不同的路由里。<br>
`$route`是$router跳转到的当前一个对象，里面包含该对象的path、query、name、params<br>

#### 七、Vue组件之间的传值？
**1.父传子**<br>
子组件通过`props属性`接收从父组件传过来的值，父组件传值的时候使用v-bind将子组件中预留的变量名绑定为data里面的数据。<br>
子组件：<br>
```html
// 在 .vue 文件中的写法
<template>
  <h3>{% raw %}{{msg}}{% endraw %}</h3>
</template>
<script>
export default {
  props:{
    msg: String
  }
  // 或者 props:['msg']
};
</script>
```
父组件：<br>
```html
<template>
  <div>
    <input type="text" v-model="message" @change="dataChange">
    <Child :msg="message"></Child>
  </div>
</template>
<script>
import Child from "@/components/Child";
export default {
  data() {
    return {
      message: "父组件的值"
    };
  },
  methods: {
    dataChange(data){
      this.msg = data
    }
  },
  components: { Child }
}
</script>
```

```html
// 在 .html 文件中的写法
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>组件之间通信</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
</head>
<body>
<!--父组件里调用子组件-->
<div id="parent">
    <Child message="第一次调用" imgsrc="images/ad1.png"></Child>
    <Child message="第二次" imgsrc="images/ad2.png"></Child>
</div>

<!--定义一个子组件-->
<template id="child">
    <div>
        <h1>{{message}}</h1>
        <img :src="imgsrc" width="300">
    </div>
</template>

<script>
    Vue.component('Child',{
        template: '#child',
        props: ['message', 'imgsrc']
    });

    new Vue({
        el: '#parent',
    })
</script>
</body>
</html>
```

**2.子传父**<br>
首先子组件中用按钮来触发`setData`事件，在`setData`中用`this.$emit`来遍历父组件中`getData`事件，最后返回`this.msg`<br>
子组件：<br>
```html
<template>
  <input type="text" v-model="msg">
  <button @click="setData">传递到父组件</button>
</template>
<script>
export default {
  data() {
    return {
      msg: "传递给父组件的值"
    };
  },
  methods: {
    setData() {
      this.$emit("getData",this.msg);
    }
  }
};
</script>
```
父组件：<br>
```html
<template>
  <div>
    <Child @getData="getData"></Child>
    <p>{% raw %}{{message}}{% endraw %}</p>
  </div>
</template>
<script>
import Child from "@/components/Child";
export default {
  data() {
    return {
      message: "父组件默认值"
    };
  },
  methods: {
    getData(data){
      this.msg = data
    }
  },
  components: { Child }
}
</script>
```
**3.兄弟组件互相传值**<br>
①通过Vuex状态管理传值：先通过npm加载vuex，创建store.js文件<br>
```javascript
//store.js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex);
const state={name:'Violetks'};
const mutations={
  newName(state,message){
    state.name=message
  }
}
export default new Vuex.Store({state,mutations})
```
②引入bus.js文件，发布者订阅者模式<br>
```css
import Bus from './bus.js'
```
```javascript
//一个子组件触发
methods:{
  Bus.$emit('触发的方法名'，需要传递的值);
}
```
```javascript
//一个子组件监听
mounted:{
  bus.$on("方法名",(传递的值)=>{ })
}
```
③使用`$root`<br>
```javascript
//一个子组件触发
this.$root.$emit('触发的方法名'，需要传递的值);
//一个子组件监听
this.$root.$off("方法名");//每次进入先关闭一下
this.$root.$on("方法名",(传递的值)=>{ })
```

**4.多层组件之间的通信**<br>
```html
// 一个父组件里有两个子组件
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>多层组件通信</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
</head>
<body>
<div id="app">
    <my-parent :imgtitle="title" :imgsrc="img"></my-parent>
</div>

<template id="my_img">
    <img :src="imgsrc" width="200">
</template>

<template id="my_title">
    <h2>{{title}}</h2>
</template>

<template id="my_parent">
    <div>
        <child1 :imgsrc="imgsrc"></child1>
        <child2 :title="imgtitle"></child2>
    </div>
</template>

<script src="js/vue.js"></script>
<script>

    // 1. 子组件的实例
    let Child1 = Vue.extend({
        template: '#my_img',
        props: ['imgsrc']
    });

    let Child2 = Vue.extend({
        template: '#my_title',
        props: ['title']
    });

    // 2. 注册父组件
    Vue.component('my-parent', {
        props: ['imgtitle', 'imgsrc'],
        components: {
            'child1': Child1,
            'child2': Child2
        },
        template: '#my_parent'
    });

    new Vue({
        el: '#app',
        data: {
            title: '我是不是很漂亮',
            img: 'img/img_01.jpg'
        }
    });
</script>
</body>
</html>
```

#### 八、Vuex的功能？能否进行兄弟组件之间的传值？
[Vuex](https://vuex.vuejs.org/zh/)是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用**集中式存储**管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>
主要用于管理vue中的共享状态，可以兄弟组件互相传值；

![lqZmcT.png](https://s2.ax1x.com/2020/01/14/lqZmcT.png)
 <!-- ![lqZmcT.png](/instructPic/lqZmcT.png) -->

上图的说明：<br>
①**Vue Components**是**vue 组件**，会触发（dispatch）一些事件或动作（**Actions**）；<br>
②在 **vuex** 中，数据是集中管理的，我们不能直接去更改数据，所以会把这个动作（Commit）到 **Mutations** 中；<br>
③接着 **Mutations** 就去改变（Mutate）**State** 中的数据；<br>
④当 **State** 中的数据改变之后，就会重新渲染（Render）到**Vue Components**中，**Vue Components**展示更新后的数据。<br>

**Vuex 的核心是 Store（仓库）**，相当于是一个容器。一个Store实例中包含以下属性和方法：<br>
**state**定义属性（状态、数据）；<br>
**mutations**定义方法（动作）：通过提交 mutations 的方式，而非直接改变 `store.state.count`。<br>
通过 `store.state` 来获取状态对象，以及通过 `store.commit` 方法触发状态变更。<br>

#### 九、Axios
Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。<br>
- (Axios 使用说明)[https://www.kancloud.cn/yunye/axios/234845]
- (Axios 中文网)[http://www.axios-js.com/]
- (Axios 源码深度剖析)[https://juejin.im/post/5b0ba2d56fb9a00a1357a334]

#### 十、如何将axios异步请求同步化处理？
```javascript
//使用 asyns/await
async getHistoryData (data) {
 try {
   let res = await axios.get('/api/survey/list/', {
     params: data
   })
   this.tableData = res.data.result
   this.totalData = res.data.count
 } catch (err) {
   console.log(err)
   alert('请求出错！')
 }
}
```

#### 十一、你有封装过axios吗？主要是封装哪方面的？
![aGiZ7j.png](https://s1.ax1x.com/2020/08/01/aGiZ7j.png)
 <!-- ![aGiZ7j.png](/instructPic/aGiZ7j.png) -->

到具体的页面中应用：

![aGii1f.png](https://s1.ax1x.com/2020/08/01/aGii1f.png)
 <!-- ![aGii1f.png](/instructPic/aGii1f.png) -->

#### 十二、单页应用（SPA）与多页应用（MPA）的区别
**1、多页应用**<br>
有多个独立的页面的应用，每个公共资源（js、css等）需选择性重新加载，多页面跳转刷新所有资源。每一次页面跳转时，服务器都会返回一个新的html文档。常用于app或客户端等。<br>
**2、多页应用的优缺点：**<br>
（1）首屏时间快：首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个html，页面就会展示出来，这个过程只经历了一个HTTP请求，所以页面展示的速度非常快。<br>
（2）搜索引擎优化效果好（SEO）：搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在Html中，所以这种多页应用，SEO排名效果好。<br>
（3）页面切换慢：因为每次跳转都需要发出一个http请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。<br>
**3、单页应用**<br>
只有一个Web主页面的应用，公共资源（js、css等）仅需加载一次，所有的内容都包含在主页面，对每一个功能模块组件化。单页应用的跳转就是切换相关组件，仅刷新局部资源。常用于PC端官网、购物等网站。<br>
第一次进入页面时会请求一个html文件，切换到其他组件时页面路径发生改变，但是并没有新的html文件请求，页面内容也变化了。**原理：**JS能检测到url的变化，通过这一点，可以用js动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个页面路由并不是通过服务端来做的，而是通过前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求html文件。<br>
**4、单页应用的优缺点：**<br>
（1）页面切换快：页面每次切换跳转时，并不需要做html文件的请求，节约了很多http发送时延，切换页面的时候速度很快。<br>
（2）首屏时间慢：单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。<br>
（3）不利于SEO：SEO效果差，因为搜索引擎只认识html里的内容，不认识js的内容，而单页应用的内容都是靠js渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。<br>
**5、表格对比：**<br>
![SPA与MPA.png](/instructPic/SPA与MPA.png)

#### 十三、Vue中如何优化首页加载速度
1、路由懒加载，首页加载的时候，不让其他页面加载，减缓首页压力。<br>
2、element-ui等组件库按需加入。<br>
3、首先打包时可以分为多个模块，其次要缩小文件体积，一些第三方库可以通过外链的方式引入。<br>

#### 十四、component标签的作用
```html
<component :is="componentId"></component>
```
Vue中提供了 `<component>` 内置组件，通过它的 `is` 属性可以实现像多标签界面中不同组件的动态切换，创建动态组件。<br>
#### 十五、keep-alive标签的原理是什么？有什么功能？
```html
<!-- 失活的组件将会被缓存！-->
<keep-alive :include="allowList" :exclude="noAllowList" :max="amount">
  <component :is="componentId"></component>
</keep-alive>
```
Vue中提供了 `<keep-alive>` 内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件，自身不会渲染成一个DOM元素，也不会出现在父组件链中。<br>
**作用：**在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。<br>
**属性：**<br>
（1）`include`：可传字符串、正则表达式、数组。只有名称匹配的组件会被缓存。<br>
（2）`exclude`：可传字符串、正则表达式、数组。任何名称匹配的组件都不会被缓存。<br>
（3）`max`：数字。最多可以缓存多少组件实例。<br>
**生命周期：**被包含在 `<keep-alive>` 中创建的组件，会多出两个生命周期钩子 `activated` 和 `deactivated`。<br>
1、`activated`，在 `<keep-alive>` 组件激活时调用。<br>
2、`deactivated`，在 `<keep-alive>` 组件停用时调用。<br>

#### 十六、Mixin混入
混入（mixin）可以用于分发Vue组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>
1、定义一个混入对象。混入对象和组件对象基本是相同，都有data、method和一系列生命周期钩子函数。<br>
```javascript
// mixin.js
const myMixin = {
  data () {
    return {
      mixinData: "混入的数据",
      obj: { name: "zhangsan", gender: "male" }
    }
  },
  created () {
    console.log("混入的created");
  },
  methods: {
    test () {
      console.log("混入的method");
    }
  }
}
```
2、混入分为局部混入和全局混入两种方式。<br>
（1）局部混入：在需要使用的组件中，用 `mixins` 属性来混入， `mixins` 是一个数组，可以使用多个混入。<br>
```javascript
let vm = new Vue({
  el: "#app",
  mixins: [myMixin], // 局部混入
  data: {
    msg: "hello"
  },
  created () {
    console.log("Vue的created")
  }
})
```
（2）全局混入：将定义的混入对象注册到全局，每个Vue实例都会混入这个对象，应当避免使用。<br>
```javascript
Vue.mixin(myMixin)
```
3、混入的规则。<br>
（1）`data` 数据对象进行合并，发生冲突时以组件数据优先，组件中的数据会覆盖混入对象的数据。<br>
（2）生命周期钩子函数混合为一个数组，当使用组件时，组件的函数和混合的函数都执行，先执行混入中的函数，再执行组件自身的函数。<br>
（3）值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。<br>
