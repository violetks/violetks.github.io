---
layout:     post
title:      Vue2基础知识（二）
date:       2023-01-02
author:     violetks
header-img: img/post-vue.jpg
catalog: true
tags:
    - Vue
---

#### 一、Vue的生命周期有哪些？它们有什么不同？
Vue生命周期是指vue实例对象从创建之初到销毁的过程。vue的生命周期总共分为8个阶段：创建前后，载入前后，更新前后，销毁前后。`beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`update`、`beforeDestroy`、`destroyed`，**第一次加载页面会触发前四个钩子**。<br>

生命周期钩子 | 组件状态 | 响应类型 | 最佳实践
---|---|---|---
 beforeCreate | 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据 | 拿不到任何信息，无法篡改数据，一般做loading，此时的vue实例还什么都没有，但是`$route`对象是存在的，可以根据路由信息进行**重定向**之类的操作。 | 常用于初始化非响应式变量
 created | 实例创建完成，可以访问方法和数据，还未挂载到DOM，不能访问到`$el`属性，`$ref`属性内容为空数组 | `$el`，没有初始化，数据已加载完成，可以篡改数据，并更新，不会触发`beforeUpdate`，`updated`，在这结束loading，还做一些初始化，实现函数自执行 ，`$ref`属性内容为空数组；定义getter、setter存储器属性，在实例创建之后被调用，该阶段可以访问data，**可以使用this**。该阶段允许执行http请求操作。 | 常用于**简单的ajax请求**，页面的初始化
 beforeMount | 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 | $el已被初始化，数据已加载完成，可以篡改数据，并更新，不会触发beforeUpdate，updated。将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。**相关render函数首次被调用**。 | /
 mounted | 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 | $el已被初始化，数据已加载完成，可以篡改数据，并更新，并且触发beforeUpdate，updated，在这发起后端请求，拿回数据，配合路由钩子做一些事情；在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听 | 常用于获取信息和操作，**ajax请求**
 beforeUpdate | 响应式数据更新时调用，发生在虚拟DOM打补丁之前 | $vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改$vm.data，并不会触发附加的重渲染过程。 | 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
 updated | 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 | 虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环 | 避免在这个钩子函数中操作数据，可能陷入死循环
 beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 | / | 常用于销毁定时器、解绑全局事件、销毁插件对象等操作
 destroyed | 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 | / | /

 ![lbhGrR.jpg](https://s2.ax1x.com/2020/01/14/lbhGrR.jpg)
 <!-- ![lbhGrR.jpg](/instructPic/lbhGrR.jpg) -->

#### 二、数据请求在生命周期哪一个阶段？created和mounted之间的区别？
一般在`created`（或beforeRouter）里面就可以，如果涉及到需要页面加载完成之后的话就用`mounted`。主要区别在于**是否需要操作DOM结构**。<br>
1、在`created`的时候，视图中的HTML并没有渲染出来，所以此时如果直接去操作DOM节点，一定找不到相关元素；<br>
2、在`mounted`中，HTML已经渲染出来了，可以直接操作DOM节点，`document.getelementById`生效。<br>

#### 三、Vue组件基础
Vue组件是可复用的Vue实例，它们与`new Vue`接收相同的选项，例如`data`、`computed`、`watch`、`methods`以及生命周期钩子等。注意每个组件都会各自独立维护它的数据，每用一次组件，就会有一个它的新实例被创建。<br>
Vue中使用组件的三大步骤：1、创建组件，使用`Vue.extend(options)`；2、注册组件；3、使用组件；<br>
```javascript
// 注册一个全局组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {% raw %}{{ count }}{% endraw %} times.</button>'
})
// 注册一个局部组件
components: {...}
```

#### 四、Vue中，data属性为什么必须声明为一个返回初始数据的函数？
data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，互不影响。如果不用function返回，每个组件的data都是内存的同一个地址，一个实例中数据改变了其他实例的也跟着改变。data函数中的this是Vue实例对象。<br>
```javascript
//如果直接赋值，两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改
var MyComponent = function() {}
MyComponent.prototype.data = {
  a: 1,
  b: 2
}

//两个组件实例，通过<my-component>调用，创建的两个实例
var component1 = new MyComponent()
var component2 = new MyComponent()

component1.data.a === component2.data.a;  //true
component1.data.b = 5;
component2.data.b;  //5
```
```html
Vue.component('my-component',{
  template: '<div>OK</div>',
  data() {
    return {} //返回一个唯一的对象，不要和其他组件共用一个对象进行返回
  }
})
```

#### 五、render函数
render函数是Vue2新增的一个函数，主要用来提升节点的性能，它是基于JavaScript计算。使用render函数将template里面的节点解析成虚拟DOM。<br>
Vue推荐在绝大多数情况下使用模板来创建你的HTML。然而在一些场景中，你真的需要JavaScript的完全编程能力。这时可以用渲染函数，它比模板更接近编译器。<br>
简单来说，在Vue中我们使用模板HTML语法组建页面的，使用render函数我们可以用JavaScript语言来构建DOM。因为Vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，Vue就免去了转译的过程。<br>
```javascript
new Vue({
  el: "#app",
  render: h => h(App)
})
```
关于不同版本的Vue：<br>
1、vue.js与vue.runtime.xxx.js的区别：<br>
（1）vue.js是完整版的Vue，包含核心功能和模板解析器；<br>
（2）vue.runtime.xxx.js是运行版的Vue，只包含核心功能，没有模板解析器。<br>
2、因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。<br>

#### 六、ref属性
`ref`被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的`$refs`对象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例。<br>

#### 七、Props配置项
1、功能：让组件接收外部传过来的数据；<br>
2、Prop类型：<br>
（1）以字符串数组形式列出prop：<br>
```javascript
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```
（2）限制类型，每个prop都有指定的值类型，以对象形式列出prop：<br>
```javascript
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
```
（3）Prop验证，为props中的值提供一个带有验证需求的对象：<br>
```javascript
props: {
  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
  propA: Number,
  // 多个可能的类型
  propB: [String, Number],
  // 必填的字符串
  propC: {
    type: String,
    required: true
  },
  // 带有默认值的数字
  propD: {
    type: Number,
    default: 100
  },
  // 带有默认值的对象
  propE: {
    type: Object,
    // 对象或数组默认值必须从一个工厂函数获取
    default: function () {
      return { message: 'hello' }
    }
  },
  // 自定义验证函数
  propF: {
    validator: function (value) {
      // 这个值必须匹配下列字符串中的一个
      return ['success', 'warning', 'danger'].includes(value)
    }
  }
}
```
3、props是只读的，Vue底层会监测你对props的修改，如果进行了修改就会发出警告。子组件不能修改从props获取到的数据。<br>

#### 八、Mixin混入
混入（mixin）可以用于分发Vue组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>
1、定义一个混入对象。混入对象和组件对象基本是相同，都有data、method和一系列生命周期钩子函数。<br>
```javascript
// mixin.js
const myMixin = {
  data () {
    return {
      mixinData: "混入的数据",
      obj: { name: "zhangsan", gender: "male" }
    }
  },
  created () {
    console.log("混入的created");
  },
  methods: {
    test () {
      console.log("混入的method");
    }
  }
}
```
2、混入分为局部混入和全局混入两种方式。<br>
（1）局部混入：在需要使用的组件中，用 `mixins` 属性来混入， `mixins` 是一个数组，可以使用多个混入。<br>
```javascript
let vm = new Vue({
  el: "#app",
  mixins: [myMixin], // 局部混入
  data: {
    msg: "hello"
  },
  created () {
    console.log("Vue的created")
  }
})
```
（2）全局混入：将定义的混入对象注册到全局，每个Vue实例都会混入这个对象，应当避免使用。<br>
```javascript
Vue.mixin(myMixin)
```
3、混入的规则。<br>
（1）`data` 数据对象进行合并，发生冲突时以组件数据优先，组件中的数据会覆盖混入对象的数据。<br>
（2）生命周期钩子函数混合为一个数组，当使用组件时，组件的函数和混合的函数都执行，先执行混入中的函数，再执行组件自身的函数。<br>
（3）值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。<br>

#### 九、插件
1、功能：用于增强Vue；<br>
2、本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。<br>
3、定义插件：<br>
```javascript
obj.install = function (Vue, options) {
  // 1、添加全局过滤器
  Vue.filter(...)

  // 2、添加全局指令
  Vue.directive(...)

  // 3、配置全局混入
  Vue.mixin(...)

  // 4、添加实例方法
  Vue.prototype.$myMethod = function () {...}
  Vue.prototype.$myProperty = xxxx
}
```
4、使用插件：<br>
```javascript
Vue.use()
```

#### 十、Vue的slot插槽（匿名&具名&作用域）
Vue实现了一套内容分发的API，将`<slot></slot>`元素作为承载分发内容的出口，没有插槽的情况下在组件标签内一些内容是不起任何作用的。<br>
**具名插槽**，当需要使用插槽时，可以使用`<slot>`的特性`:name`，定义额外的插槽。<br>
**作用域插槽**，作用域插槽就是父组件在**调用子组件的时候给子组件传了一个插槽**，这个插槽为作用域插槽，该插槽必须放在`<template>`标签里面，同时声明从子组件接收的数据放在一个自定义属性内，并定义该数据的渲染方式。<br>
在2.6.0中，为具名插槽和作用域插槽引入了一个`v-slot`指令，它取代了`slot`和`slot-scope`。<br>
```html
<div id="app">
<child>
  <template slot-scope="props">  <!--该插槽必须放在template标签内-->
    <li></li>  <!--定义渲染方式-->
  </template>
</child>
</div>
```
```html
Vue.component('child',{
  data: {
    list:[1,2,3,4]
  },
  template:`<div>
                <ul>
                   <slot v-for="value in list" :value=value>  //使用slot占位
                   </slot>
                </ul>
            </div>`
})
new Vue({
  el: '#app'
})
```

#### 十一、$route和$router的区别
`$router`是一个VueRouter的实例，可以导航到不同的路由里。<br>
`$route`是$router跳转到的当前一个对象，里面包含该对象的path、query、name、params<br>

#### 十二、Vue组件之间的传值？
**1.父传子**<br>
子组件通过`props属性`接收从父组件传过来的值，父组件传值的时候使用v-bind将子组件中预留的变量名绑定为data里面的数据。<br>
子组件：<br>
```html
// 在 .vue 文件中的写法
<template>
  <h3>{% raw %}{{msg}}{% endraw %}</h3>
</template>
<script>
export default {
  props:{
    msg: String
  }
  // 或者 props:['msg']
};
</script>
```
父组件：<br>
```html
<template>
  <div>
    <input type="text" v-model="message" @change="dataChange">
    <Child :msg="message"></Child>
  </div>
</template>
<script>
import Child from "@/components/Child";
export default {
  data() {
    return {
      message: "父组件的值"
    };
  },
  methods: {
    dataChange(data){
      this.msg = data
    }
  },
  components: { Child }
}
</script>
```

```html
// 在 .html 文件中的写法
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>组件之间通信</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
</head>
<body>
<!--父组件里调用子组件-->
<div id="parent">
    <Child message="第一次调用" imgsrc="images/ad1.png"></Child>
    <Child message="第二次" imgsrc="images/ad2.png"></Child>
</div>

<!--定义一个子组件-->
<template id="child">
    <div>
        <h1>{% raw %}{{message}}{% endraw %}</h1>
        <img :src="imgsrc" width="300">
    </div>
</template>

<script>
    Vue.component('Child',{
        template: '#child',
        props: ['message', 'imgsrc']
    });

    new Vue({
        el: '#parent',
    })
</script>
</body>
</html>
```

**2.子传父**<br>
首先子组件中用按钮来触发`setData`事件，在`setData`中用`this.$emit`来遍历父组件中`getData`事件，最后返回`this.msg`<br>
子组件：<br>
```html
<template>
  <input type="text" v-model="msg">
  <button @click="setData">传递到父组件</button>
</template>
<script>
export default {
  data() {
    return {
      msg: "传递给父组件的值"
    };
  },
  methods: {
    setData() {
      this.$emit("getData",this.msg);
    }
  }
};
</script>
```
父组件：<br>
```html
<template>
  <div>
    <Child @getData="getData"></Child>
    <p>{% raw %}{{message}}{% endraw %}</p>
  </div>
</template>
<script>
import Child from "@/components/Child";
export default {
  data() {
    return {
      message: "父组件默认值"
    };
  },
  methods: {
    getData(data){
      this.msg = data
    }
  },
  components: { Child }
}
</script>
```
**3.兄弟组件互相传值**<br>
①通过Vuex状态管理传值：先通过npm加载vuex，创建store.js文件<br>
```javascript
//store.js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex);
const state={name:'Violetks'};
const mutations={
  newName(state,message){
    state.name=message
  }
}
export default new Vuex.Store({state,mutations})
```
②引入bus.js文件，发布者订阅者模式<br>
```css
import Bus from './bus.js'
```
```javascript
//一个子组件触发
methods:{
  Bus.$emit('触发的方法名'，需要传递的值);
}
```
```javascript
//一个子组件监听
mounted:{
  bus.$on("方法名",(传递的值)=>{ })
}
```
③使用`$root`<br>
```javascript
//一个子组件触发
this.$root.$emit('触发的方法名'，需要传递的值);
//一个子组件监听
this.$root.$off("方法名");//每次进入先关闭一下
this.$root.$on("方法名",(传递的值)=>{ })
```

**4.多层组件之间的通信**<br>
```html
// 一个父组件里有两个子组件
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>多层组件通信</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
</head>
<body>
<div id="app">
    <my-parent :imgtitle="title" :imgsrc="img"></my-parent>
</div>

<template id="my_img">
    <img :src="imgsrc" width="200">
</template>

<template id="my_title">
    <h2>{% raw %}{{title}}{% endraw %}</h2>
</template>

<template id="my_parent">
    <div>
        <child1 :imgsrc="imgsrc"></child1>
        <child2 :title="imgtitle"></child2>
    </div>
</template>

<script src="js/vue.js"></script>
<script>

    // 1. 子组件的实例
    let Child1 = Vue.extend({
        template: '#my_img',
        props: ['imgsrc']
    });

    let Child2 = Vue.extend({
        template: '#my_title',
        props: ['title']
    });

    // 2. 注册父组件
    Vue.component('my-parent', {
        props: ['imgtitle', 'imgsrc'],
        components: {
            'child1': Child1,
            'child2': Child2
        },
        template: '#my_parent'
    });

    new Vue({
        el: '#app',
        data: {
            title: '我是不是很漂亮',
            img: 'img/img_01.jpg'
        }
    });
</script>
</body>
</html>
```