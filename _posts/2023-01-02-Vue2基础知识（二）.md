---
layout:     post
title:      Vue2基础知识（二）
date:       2023-01-02
author:     violetks
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - Vue2
---

#### 一、Vue的生命周期有哪些？它们有什么不同？
Vue生命周期是指vue实例对象从创建之初到销毁的过程。vue的生命周期总共分为8个阶段：创建前后，载入前后，更新前后，销毁前后。`beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`update`、`beforeDestroy`、`destroyed`，**第一次加载页面会触发前四个钩子**。<br>

生命周期钩子 | 组件状态 | 响应类型 | 最佳实践
---|---|---|---
 beforeCreate | 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据 | 拿不到任何信息，无法篡改数据，一般做loading，此时的vue实例还什么都没有，但是`$route`对象是存在的，可以根据路由信息进行**重定向**之类的操作。 | 常用于初始化非响应式变量
 created | 实例创建完成，可以访问方法和数据，还未挂载到DOM，不能访问到`$el`属性，`$ref`属性内容为空数组 | `$el`，没有初始化，数据已加载完成，可以篡改数据，并更新，不会触发`beforeUpdate`，`updated`，在这结束loading，还做一些初始化，实现函数自执行 ，`$ref`属性内容为空数组；定义getter、setter存储器属性，在实例创建之后被调用，该阶段可以访问data，**可以使用this**。该阶段允许执行http请求操作。 | 常用于**简单的ajax请求**，页面的初始化
 beforeMount | 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 | $el已被初始化，数据已加载完成，可以篡改数据，并更新，不会触发beforeUpdate，updated。将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。**相关render函数首次被调用**。 | /
 mounted | 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 | $el已被初始化，数据已加载完成，可以篡改数据，并更新，并且触发beforeUpdate，updated，在这发起后端请求，拿回数据，配合路由钩子做一些事情；在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听 | 常用于获取信息和操作，**ajax请求**
 beforeUpdate | 响应式数据更新时调用，发生在虚拟DOM打补丁之前 | $vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改$vm.data，并不会触发附加的重渲染过程。 | 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
 updated | 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 | 虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环 | 避免在这个钩子函数中操作数据，可能陷入死循环
 beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 | / | 常用于销毁定时器、解绑全局事件、销毁插件对象等操作
 destroyed | 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 | / | /

 ![lbhGrR.jpg](https://s2.ax1x.com/2020/01/14/lbhGrR.jpg)
 <!-- ![lbhGrR.jpg](/instructPic/lbhGrR.jpg) -->

#### 二、数据请求在生命周期哪一个阶段？created和mounted之间的区别？
一般在`created`（或beforeRouter）里面就可以，如果涉及到需要页面加载完成之后的话就用`mounted`。主要区别在于**是否需要操作DOM结构**。<br>
1、在`created`的时候，视图中的HTML并没有渲染出来，所以此时如果直接去操作DOM节点，一定找不到相关元素；<br>
2、在`mounted`中，HTML已经渲染出来了，可以直接操作DOM节点，`document.getelementById`生效。<br>

#### 三、Vue组件基础
Vue组件是可复用的Vue实例，它们与`new Vue`接收相同的选项，例如`data`、`computed`、`watch`、`methods`以及生命周期钩子等。注意每个组件都会各自独立维护它的数据，每用一次组件，就会有一个它的新实例被创建。<br>
Vue中使用组件的三大步骤：1、创建组件，使用`Vue.extend(options)`；2、注册组件；3、使用组件；<br>
```javascript
// 注册一个全局组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {% raw %}{{ count }}{% endraw %} times.</button>'
})
// 注册一个局部组件
components: {...}
```

#### 四、Vue中，data属性为什么必须声明为一个返回初始数据的函数？
data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，互不影响。如果不用function返回，每个组件的data都是内存的同一个地址，一个实例中数据改变了其他实例的也跟着改变。data函数中的this是Vue实例对象。<br>
```javascript
//如果直接赋值，两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改
var MyComponent = function() {}
MyComponent.prototype.data = {
  a: 1,
  b: 2
}

//两个组件实例，通过<my-component>调用，创建的两个实例
var component1 = new MyComponent()
var component2 = new MyComponent()

component1.data.a === component2.data.a;  //true
component1.data.b = 5;
component2.data.b;  //5
```
```html
Vue.component('my-component', {
  template: '<div>OK</div>',
  data () {
    return {} //返回一个唯一的对象，不要和其他组件共用一个对象进行返回
  }
})
```

#### 五、render函数
`render`函数是Vue2新增的一个函数，主要用来提升节点的性能，它是基于JavaScript计算。使用`render`函数将template里面的节点解析成虚拟DOM。<br>
Vue推荐在绝大多数情况下使用模板来创建你的HTML。然而在一些场景中，你真的需要JavaScript的完全编程能力。这时可以用渲染函数，它比模板更接近编译器。<br>
简单来说，在Vue中我们使用模板HTML语法组建页面的，使用`render`函数我们可以用JavaScript语言来构建DOM。因为Vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用`render`函数构建DOM，Vue就免去了转译的过程。<br>
```javascript
new Vue({
  el: "#app",
  render: h => h(App)
})
```
关于不同版本的Vue：<br>
1、vue.js与vue.runtime.xxx.js的区别：<br>
（1）vue.js是完整版的Vue，包含核心功能和模板解析器；<br>
（2）vue.runtime.xxx.js是运行版的Vue，只包含核心功能，没有模板解析器。<br>
2、因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用`render`函数接收到的`createElement`函数去指定具体内容。<br>

#### 六、ref属性
`ref`被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的`$refs`对象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例。<br>

#### 七、Props配置项
1、功能：让组件接收外部传过来的数据；<br>
2、Prop类型：<br>
（1）以字符串数组形式列出prop：<br>
```javascript
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```
（2）限制类型，每个prop都有指定的值类型，以对象形式列出prop：<br>
```javascript
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
```
（3）Prop验证，为props中的值提供一个带有验证需求的对象：<br>
```javascript
props: {
  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
  propA: Number,
  // 多个可能的类型
  propB: [String, Number],
  // 必填的字符串
  propC: {
    type: String,
    required: true
  },
  // 带有默认值的数字
  propD: {
    type: Number,
    default: 100
  },
  // 带有默认值的对象
  propE: {
    type: Object,
    // 对象或数组默认值必须从一个工厂函数获取
    default: function () {
      return { message: 'hello' }
    }
  },
  // 自定义验证函数
  propF: {
    validator: function (value) {
      // 这个值必须匹配下列字符串中的一个
      return ['success', 'warning', 'danger'].includes(value)
    }
  }
}
```
3、props是只读的，Vue底层会监测你对props的修改，如果进行了修改就会发出警告。子组件不能修改从props获取到的数据。<br>

#### 八、Mixin混入
混入（mixin）可以用于分发Vue组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>
1、定义一个混入对象。混入对象和组件对象基本是相同，都有data、method和一系列生命周期钩子函数。<br>
```javascript
// mixin.js
const myMixin = {
  data () {
    return {
      mixinData: "混入的数据",
      obj: { name: "zhangsan", gender: "male" }
    }
  },
  created () {
    console.log("混入的created");
  },
  methods: {
    test () {
      console.log("混入的method");
    }
  }
}
```
2、混入分为局部混入和全局混入两种方式。<br>
（1）局部混入：在需要使用的组件中，用`mixins`属性来混入，`mixins`是一个数组，可以使用多个混入。<br>
```javascript
let vm = new Vue({
  el: "#app",
  mixins: [myMixin], // 局部混入
  data: {
    msg: "hello"
  },
  created () {
    console.log("Vue的created")
  }
})
```
（2）全局混入：将定义的混入对象注册到全局，每个Vue实例都会混入这个对象，应当避免使用。<br>
```javascript
Vue.mixin(myMixin)
```
3、混入的规则。<br>
（1）`data`数据对象进行合并，发生冲突时以组件数据优先，组件中的数据会覆盖混入对象的数据。<br>
（2）生命周期钩子函数混合为一个数组，当使用组件时，组件的函数和混合的函数都执行，先执行混入中的函数，再执行组件自身的函数。<br>
（3）值为对象的选项，例如`methods`、`components`和`directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。<br>

#### 九、插件
1、插件通常用来为Vue添加全局功能。**插件的功能**范围没有严格的限制，一般有下面几种：<br>
（1）添加全局方法或者属性；<br>
（2）添加全局资源：指令/过滤器/过渡等；<br>
（3）通过全局混入来添加一些组件选项；<br>
（4）添加Vue实例方法，通过把它们添加到`Vue.prototype`上实现；<br>
（5）一个库，提供自己的API，同时提供上面提到的一个或多个功能；<br>
2、本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。<br>
3、定义插件：<br>
```javascript
MyPlugin.install = function (Vue, options) {
  // 1、添加全局过滤器
  Vue.filter(...)

  // 2、添加全局指令
  Vue.directive(...)

  // 3、配置全局混入
  Vue.mixin(...)

  // 4、添加实例方法
  Vue.prototype.$myMethod = function () {...}
  Vue.prototype.$myProperty = xxxx
}
```
4、使用插件：<br>
```javascript
Vue.use(MyPlugin)
```
`Vue.use`会自动阻止多次注册相同插件，即使多次调用也只会注册一次该插件。<br>

#### 十、组件的自定义事件
1、一种组件间通讯的方式。适用于：子组件给父组件传值。<br>
2、使用场景：子组件想给父组件传数据，那么就要在父组件中给子组件绑定自定义事件（事件的回调在父组件中）。<br>
3、在父组件中给子组件绑定自定义事件的两种方式：<br>
```html
<!-- 方法一 -->
<Child @custom="test" />
<!-- 方法二：用 $on，this.test是在父组件中定义的回调 -->
<Child ref="child" />

mounted () {
  this.$refs.child.$on("custom", this.test)
}
```
若想让自定义事件只能触发一次，可以使用`once`修饰符，或`$once`方法。<br>
4、触发自定义事件：在子组件中，`this.$emit("custom", 数据)`；<br>
5、解绑自定义事件：`this.$off("custom")`；<br>
6、组件上也可以绑定原生DOM事件，需要使用`native`修饰符；<br>
7、注意：通过`this.$refs.xxx.$on("custom", 回调)`绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题。<br>

#### 十一、Vue组件之间的传值
**1、父传子**<br>
子组件通过`props属性`接收从父组件传过来的值，父组件传值的时候使用v-bind将子组件中预留的变量名绑定为data里面的数据。<br>
```html
<!-- 在 .vue 文件中的写法 -->
<!-- 子组件 -->
<template>
  <h3>{% raw %}{{msg}}{% endraw %}</h3>
</template>
<script>
export default {
  props: {
    msg: String
  }
  // 或者 props: ['msg']
};
</script>

<!-- 父组件 -->
<template>
  <div>
    <input type="text" v-model="message" @change="dataChange">
    <Child :msg="message"></Child>
  </div>
</template>
<script>
import Child from "@/components/Child";
export default {
  data () {
    return {
      message: "父组件的值"
    };
  },
  methods: {
    dataChange (data) {
      this.msg = data;
    }
  },
  components: { Child }
}
</script>
```

```html
<!-- 在 .html 文件中的写法 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>组件之间通信</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
</head>
<body>
<!-- 父组件里调用子组件 -->
<div id="parent">
    <Child message="第一次调用" imgsrc="images/ad1.png"></Child>
    <Child message="第二次" imgsrc="images/ad2.png"></Child>
</div>

<!-- 定义一个子组件 -->
<template id="child">
    <div>
        <h1>{% raw %}{{message}}{% endraw %}</h1>
        <img :src="imgsrc" width="300">
    </div>
</template>

<script>
    Vue.component('Child', {
        template: '#child',
        props: ['message', 'imgsrc']
    });

    new Vue({
        el: '#parent'
    })
</script>
</body>
</html>
```

**2、子传父**<br>
首先子组件中用按钮来触发`setData`事件，在`setData`中用`this.$emit`来遍历父组件中`getData`事件，最后返回`this.msg`；<br>
```html
<!-- 子组件 -->
<template>
  <input type="text" v-model="msg">
  <button @click="setData">传递到父组件</button>
</template>
<script>
export default {
  data () {
    return {
      msg: "传递给父组件的值"
    };
  },
  methods: {
    setData () {
      this.$emit("getData", this.msg);
    }
  }
};
</script>

<!-- 父组件 -->
<template>
  <div>
    <Child @getData="getData"></Child>
    <p>{% raw %}{{message}}{% endraw %}</p>
  </div>
</template>
<script>
import Child from "@/components/Child";
export default {
  data () {
    return {
      message: "父组件默认值"
    };
  },
  methods: {
    getData (data) {
      this.msg = data;
    }
  },
  components: { Child }
}
</script>
```
**3、兄弟组件互相传值**<br>
（1）通过事件总线（EventBus），即通过`on`监听，`emit`触发的方式；<br>
①创建一个`bus.js`文件，里面定义一个新的Vue实例专门用于传递数据，并导出；<br>
```javascript
// bus.js
import Vue from "vue";
export default new Vue;
```
②在子组件A里定义传递的方法名和传输内容，点击事件或钩子函数触发`bus.$emit`事件；<br>
```html
<!-- 子组件A -->
<template>
  <button @click="sendToB">点击传参给B组件</button>
</template>

<script>
import bus from "./bus.js";
export default {
  data () {
    return {
      msg: "这是A要传给B的数据"
    }
  },
  methods: {
    sendToB () {
      bus.$emit("getData", this.msg);
    }
  }
}
</script>
```
③在子组件B接收传递过来的数据，通过`bus.$on`监听；<br>
```html
<!-- 子组件B -->
<template>
  <p>组件A传过来的数据：{% raw %}{{ msg }}{% endraw %}</p>
</template>

<script>
import bus from "./bus.js";
export default {
  data () {
    return {
      msg: ""
    }
  },
  mounted () {
    bus.$on("getData", (params) => {
      this.msg = params;
    })
  }
}
</script>
```
④记得解绑`eventBus`；<br>
```javascript
bus.$off("getData");
```
（2）全局事件总线（GlobalEventBus），适用于任意组件间通信；<br>
①安装全局事件总线：<br>
```javascript
new Vue({
  ...
  beforeCreate () {
    Vue.prototype.$bus = this; // 安装全局事件总线，$bus 就是当前应用的 vm
  }
})
```
②使用事件总线：<br>
接收数据：A组件想接收数据，则在A组件中给`$bus`绑定自定义事件。事件的回调留在A组件自身。<br>
```javascript
methods: {
  demo (data) { ... }
}
...
mounted () {
  this.$bus.$on("xxx", this.demo)
}
```
提供数据：`this.$bus.$emit("xxx", 数据)`;<br>
③最好在`beforeDestroy`中用`$off`去解绑当前组件所用到的事件。<br>
（3）通过Vuex状态管理传值：先通过npm下载vuex，创建store.js文件；<br>
```javascript
//store.js
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex);
const state = { name: 'Violetks' };
const mutations = {
  newName (state, message) {
    state.name = message;
  }
}
export default new Vuex.Store({ state, mutations })
```
（4）使用`$root`<br>
```javascript
//一个子组件触发
this.$root.$emit('触发的方法名'，需要传递的值);
//一个子组件监听
this.$root.$off("方法名");//每次进入先关闭一下
this.$root.$on("方法名", (传递的值) => { })
```

#### 十二、$nexTick
1、`$nextTick`所指定的回调会在浏览器更新DOM完毕之后再执行。<br>
2、例子：从后端请求到一个列表数据后，前端直接重新赋值时页面不更新。因为**Vue更新DOM是异步更新**，无法通过同步代码赋值后马上去更新页面。<br>
3、`$nextTick`的原理：<br>
当调用`$nextTick`方法时会传入两个参数，回调函数和执行回调函数的上下文环境，如果没有提供回调函数，那么将返回`promise`对象。首先将拿到的回调函数存放到数组中，判断是否正在执行回调函数，如果当前没有在pending的时候，就会执行timeFunc，多次执行nextTick只会执行一次timerFunc，timeFunc其实就是执行异步的方法，在timeFunc方法中选择一个异步方法（首先判断是否支持promise，如果支持就将flushCallbacks放在promise中异步执行，并且标记使用微任务。如果不支持promise就看是否支持MutationObserver方法，如果支持就new了一个MutationObserver类，创建一个文本节点进行监听，当数据发生变化了就会异步执行flushCallbacks方法。如果以上两个都不支持就看是否支持setImmediate方法，如果支持setImmediate 就去异步执行flushCallbacks方法。如果以上三种方法都不支持，就使用setTimeout），然后异步去执行flushCallbacks方法，flushCallbacks中就是将传递的函数依次执行。<br>
nextTick多次调用会维持一个数组，之后会异步的把数组中的方法以此执行，这样的话用户就会在视图更新之后再获取到真实的dom元素。<br>
原理简述： nextTick 是 Vue 提供的一个全局的API ，由于Vue的异步更新策略导致我们对数据的修改不会立马体现到都没变化上，此时如果想要立即获取更新后的dom的状态，就需要使用这个方法。<br>
Vue在更新dom时是异步执行的。只要监听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓存时去重对于避免不必要的计算和dom操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。<br>

#### 十三、Vue的slot插槽（匿名&具名&作用域）
Vue实现了一套内容分发的API，将`<slot></slot>`元素作为承载分发内容的出口，没有插槽的情况下在组件标签内一些内容是不起任何作用的。<br>
1、**默认插槽**：适用于子组件中只定义一个插槽的情况，在子组件中使用`<slot></slot>`添加默认插槽，可以设置插槽默认内容；<br>
```html
<!-- 父组件中调用子组件 Child -->
<Child>
  <div>父组件想在插槽中展示的内容</div>
</Child>

<!-- 子组件中定义插槽 -->
<template>
  <div>
    <slot>插槽默认内容</slot>
  </div>
</template>
```
2、**具名插槽**：当需要在子组件中使用多个插槽时，可以使用`<slot>`的属性`:name`添加插槽名用于区分，在父组件中使用插槽时有以下两种方式；<br>
```html
<!-- 父组件中 -->
<Child>
  <!-- 方式一 -->
  <template slot="center">
    <div>父组件想在center插槽中展示的内容</div>
  </template>
  <!-- 方式二 -->
  <template v-slot:footer>
    <div>父组件想在footer插槽中展示的内容</div>
  </template>
</Child>

<!-- 子组件中 -->
<template>
  <div>
    <slot name="center">插槽默认内容</slot>
    <slot name="footer"></slot>
  </div>
</template>
```
3、**作用域插槽**：作用域插槽就是父组件在**调用子组件的时候给子组件传了一个插槽**，这个插槽为作用域插槽，该插槽必须放在`<template>`标签里面，同时声明从子组件接收的数据放在一个自定义属性内，并定义该数据的渲染方式。<br>
在2.6.0中，为具名插槽和作用域插槽引入了一个`v-slot`指令，它取代了`slot`和`slot-scope`。<br>
```html
<!-- 父组件中 -->
<Child>
  <template v-slot:default="scopeData">
    <ul>
      <li v-for="item in scopeData.list" :key="item">{% raw %}{{ item }}{% endraw %}</li>
    </ul>
  </template>
</Child>

<Child>
  <template slot-scope="scopeData">
    <h4 v-for="item in scopeData.list" :key="item">{% raw %}{{ item }}{% endraw %}</h4>
  </template>
</Child>

<!-- 子组件中 -->
<template>
  <div>
    <slot :list="list"></slot>
  </div>
</template>

<script>
export default {
  name: "Child",
  props: ["title"],
  data () {
    return {
      list: [a, b, c, d]
    }
  }
}
</script>
```

#### 十四、component标签的作用
```html
<component :is="componentId"></component>
```
Vue中提供了`<component>`内置组件，通过它的`is`属性可以实现像多标签界面中不同组件的动态切换，创建动态组件。<br>

#### 十五、keep-alive标签的原理是什么？有什么功能？
```html
<!-- 失活的组件将会被缓存！-->
<keep-alive :include="allowList" :exclude="noAllowList" :max="amount">
  <component :is="componentId"></component>
</keep-alive>
```
Vue中提供了`<keep-alive>`内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和`<transition>`相似，`<keep-alive>`是一个抽象组件，自身不会渲染成一个DOM元素，也不会出现在父组件链中。<br>
**作用：**在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。<br>
**属性：**<br>
（1）`include`：可传字符串、正则表达式、数组。只有名称匹配的组件会被缓存。<br>
（2）`exclude`：可传字符串、正则表达式、数组。任何名称匹配的组件都不会被缓存。<br>
（3）`max`：数字。最多可以缓存多少组件实例。<br>
**生命周期：**被包含在`<keep-alive>`中创建的组件，会多出两个生命周期钩子`activated`和`deactivated`。<br>
1、`activated`，在`<keep-alive>`组件激活时调用。<br>
2、`deactivated`，在`<keep-alive>`组件停用时调用。<br>
